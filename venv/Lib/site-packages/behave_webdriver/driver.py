import time
import json
import os
from functools import partial

from selenium import webdriver
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.common.exceptions import NoSuchElementException, TimeoutException, WebDriverException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.color import Color
from selenium.webdriver.support.select import Select as _Select


from behave_webdriver.conditions import (element_is_present,
                                         element_is_selected,
                                         element_contains_value,
                                         element_is_visible,
                                         element_contains_text,
                                         element_is_enabled)

# from selenium.webdriver.remote.webelement import *
from selenium.webdriver.remote.webdriver import WebDriver as RemoteWebDriver


class Select(_Select):
    def select_by_attr(self, attr, attr_value):
        css = 'option[{} ={}]'.format(attr, self._escapeString(attr_value))
        opts = self._el.find_elements(By.CSS_SELECTOR, css)
        matched = False
        for opt in opts:
            self._setSelected(opt)
            matched = True
            if not self.is_multiple:
                return
        if not matched:
            raise NoSuchElementException("Cannot locate option by {} attribue with value of '{}'".format(attr,
                                                                                                         attr_value))


class BehaveDriverMixin(RemoteWebDriver):
# class BehaveDriverMixin(object):6666666666
    """
    Implements most of the general (I.E. not browser-specific) logic for step implementations.

    Intended to be used with subclasses of any selenium webdriver.

    >>> from behave_webdriver.driver import BehaveDriverMixin
    >>> from somewhere import SomeDriver
    >>> class MyBehaveDriver(BehaveDriverMixin, SomeDriver):
    ...     pass
    >>> behave_driver = MyBehaveDriver()
    >>> behave_driver.get('https://github.com/spyoungtech/behave-webdriver')


    Can also be used with other mixins designed for selenium, such as selenium-requests

    >>> from behave_webdriver.driver import BehaveDriverMixin
    >>> from seleniumrequests import RequestMixin
    >>> from selenium import webdriver
    >>> class BehavingRequestDriver(BehaveDriverMixin, RequestMixin, webdriver.Chrome):
    ...     pass
    >>> behave_driver = BehavingRequestDriver()
    >>> response = behave_driver.request('GET', 'https://github.com/spyoungtech/behave-webdriver')


    """
    _driver_name = ''
    def __init__(self, *args, **kwargs):
        default_wait = kwargs.pop('default_wait', 1.5)
        super(BehaveDriverMixin, self).__init__(*args, **kwargs)
        self.default_wait = default_wait


    def wait(self, wait_time=None):
        if wait_time is None:
            wait_time = self.default_wait
        return WebDriverWait(self, wait_time)

    @property
    def alert(self):
        """
        Property shortcut for an ``Alert`` object for the driver
        Note: this will return an Alert instance regardless of whether or not there is actually an alert present.
        Use ``has_alert`` to check whether or not there is an alert currently present.

        :return: an selenium.webdriver.common.alert.Alert instance
        """
        return self.switch_to.alert

    @property
    def screen_size(self):
        """
        Property for the current driver window size. Can also be set by assigning an x/y tuple.

        :return: tuple of the screen dimensions (x, y)
        """
        size = self.get_window_size()
        x = size['width']
        y = size['height']
        return (x, y)

    @screen_size.setter
    def screen_size(self, size):
        """
        :param size: The dimensions to set the screen to in (x, y) format.
        :type size: tuple
        :return:
        """
        x, y = size
        if x is None:
            x = self.screen_size[0]
        if y is None:
            y = self.screen_size[1]
        self.set_window_size(x, y)

    @property
    def cookies(self):
        """
        Shortcut for driver.get_cookies()
        """
        return self.get_cookies()

    @property
    def has_alert(self):
        """
        Whether or not there is currently an alert present

        :return: True if there is an alert present, else False
        :rtype: bool
        """
        try:
            WebDriverWait(self, 1).until(EC.alert_is_present())
            alert = self.switch_to.alert
            return True
        except TimeoutException:
            return False

    @property
    def primary_handle(self):
        """
        shortcut for window_handles[0]

        :returns: the primary (first) window handle
        """
        return self.window_handles[0]

    @property
    def secondary_handles(self):
        """
        shortcut for window_handles[1:]

        :returns: list of window handles
        :rtype: list
        """
        if len(self.window_handles) > 1:
            return self.window_handles[1:]
        else:
            return []

    @property
    def last_opened_handle(self):
        return self.window_handles[-1]

    # def get_element(self, selector, by=None):
    #     """
    #     Takes a selector string and uses an appropriate method (XPATH or CSS selector by default) to find a WebElement
    #     The optional `by` argument can be supplied to specify any locating method explicitly.
    #     This is used to resolve selectors from step definition strings to actual element objects
    # 
    #     :param selector: The selector to use, an XPATH or CSS selector
    #     :type selector: str
    #     :param by: alternate method used to locate element, e.g. (By.id) See selenium.webdriver.common.by.By attributes
    #     :return: WebElement object
    #     """
    #     if by:
    #         return self.find_element(by, selector)
    #     if selector.startswith('/'):
    #         return self.find_element_by_xpath(selector)
    #     else:
    #         return self.find_element_by_css_selector(selector)

    def get_element_text(self, element):
        """
        Takes in a selector, finds the element, and extracts the text.
        When present on the WebElement, the element's 'value' property is returned. (For example, this is useful for
        getting the current text of Input elements)
        If the element has no 'value' property, the containing text is returned (elem.text)

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: the text contained within the element.
        :rtype: str
        """
        elem = self.get_element(element)
        value = elem.get_property('value')
        if value is not None:
            return value
        return elem.text

    def get_element_attribute(self, element, attr, css=False, expected_value=None):
        """
        Get the value of an attribute or css attribute from an element.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :param attr: The attribute to lookup
        :type attr: str
        :param css: Whether or not this is a CSS atrribute
        :type css: bool
        :param expected_value:
        :return: The value of the attribute
        """
        elem = self.get_element(element)
        if css:
            value = elem.value_of_css_property(attr)
            if self.is_color(value):
                value = Color.from_string(value)
            if expected_value:
                if self.is_color(expected_value):
                    expected_value = Color.from_string(expected_value)
                return value, expected_value
        else:
            value = elem.get_attribute(attr)
        return value

    def get_element_size(self, element):
        """
        Returns a dictionary containing the size information of an element.
        The dictionary has two keys: 'width' and 'height' which represent the size of the element dimensions in px

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: A dictionary with size information
        :rtype: dict
        """
        elem = self.get_element(element)
        return elem.size

    def get_element_location(self, element):
        """
        Gets the location of the element in the renderable canvas.
        This is a dict with two keys: 'x' and 'y'

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: the element's location
        :rtype: dict
        """
        elem = self.get_element(element)
        return elem.location

    def open_url(self, url):
        """
        Navigate to an absolute URL
        Behaves same as ``driver.get`` but serves as a common entry-point for subclasses wanting to change this.

        :param url: an absolute URL including the scheme
        :type url: str
        :return:
        """
        return self.get(url)

    def element_exists(self, element):
        """
        Whether or not an element exists. Attempts to locate the element using `get_element` returns True if the element
        was found, False if it couldn't be located.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: True if the element could be found, False if it couldn't be found
        :rtype: bool
        """
        try:
            self.get_element(element)  # attempt to get the element
            return True  # if it succeeded, return True
        except NoSuchElementException:
            # The element was not able to be located
            return False

    def element_visible(self, element):
        """
        Checks if an element is visible or not.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: True if the element is visible, else False
        :rtype: bool
        """
        elem = self.get_element(element)
        return elem.is_displayed()

    def element_in_viewport(self, element):
        """
        Determines the bounding box (rect) of the window and rect of the element.
        This information is used to determine whether or not the element is *completely* within the viewport.

        :param element: CSS Selector or XPATH used to locate the element
        :return:
        """
        elem = self.get_element(element)
        elem_left_bound = elem.location.get('x')
        elem_top_bound = elem.location.get('y')
        elem_width = elem.size.get('width')
        elem_height = elem.size.get('height')
        elem_right_bound = elem_left_bound + elem_width
        elem_lower_bound = elem_top_bound + elem_height

        win_upper_bound = self.execute_script('return window.pageYOffset')
        win_left_bound = self.execute_script('return window.pageXOffset')
        win_width = self.execute_script('return document.documentElement.clientWidth')
        win_height = self.execute_script('return document.documentElement.clientHeight')
        win_right_bound = win_left_bound + win_width
        win_lower_bound = win_upper_bound + win_height

        return all((win_left_bound <= elem_left_bound,
                    win_right_bound >= elem_right_bound,
                    win_upper_bound <= elem_top_bound,
                    win_lower_bound >= elem_lower_bound)
                   )

    def element_enabled(self, element):
        """
        Checks if an element is enabled or not.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: True if the element is enabled, else False
        :rtype: bool
        """
        elem = self.get_element(element)
        return elem.is_enabled()

    def element_focused(self, element):
        elem = self.get_element(element)
        focused_elem = self.switch_to.active_element
        return elem == focused_elem

    def element_selected(self, element):
        """
        Checks if an element is selected or not.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return: True if the element is selected, else False
        :rtype: bool
        """
        elem = self.get_element(element)
        return elem.is_selected()

    def element_contains(self, element, value):
        """
        Checks if an element contains (in value/text) a given string/value

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :param value: the text/value to check for
        :type value: str
        :return: True or False, whether or not the value was found in the element.
        :rtype: bool
        """
        elem = self.get_element(element)
        element_value = elem.get_property('value')
        if element_value is None:
            element_value = elem.text
        return value in element_value

    def element_has_class(self, element, cls):
        """
        Checks whether or not an element has a particular css class.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :param cls: The css class to check for
        :type cls: str
        :return: True if the element has the specified class, else False
        :rtype: bool
        """
        elem = self.get_element(element)
        elem_classes = elem.get_attribute('class')
        return cls in elem_classes

    def click_element(self, element):
        """
        Click on an element. Note: this will not trigger some doubleclick events, even when n=2 with any delay.
        Instead, if you want to doubleclick, use `doubleclick_element`

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        """
        elem = self.get_element(element)
        elem.click()

    def doubleclick_element(self, element):
        """
        Double click an element

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return:
        """
        elem = self.get_element(element)
        actions = ActionChains(self)
        actions.double_click(elem)
        actions.perform()

    def click_link_text(self, text, partial=False):
        """
        Click on a link, located by matching the text contained in the link. If ``partial`` is True,
        the link is located by partial text.

        :param text: The text contained in the link, used to locate the element.
        :type text: str
        :param partial: Whether or not to match link by partial text (as opposed to full match)
        :type partial: bool
        :return:
        """
        if partial:
            self.find_element_by_partial_link_text(text).click()
        else:
            self.find_element_by_link_text(text).click()

    def drag_element(self, element, to_element):
        """
        Drag an element to the location of another element.

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :param to_element: the selector used to locate the destination element
        :type to_element: str
        :return:
        """
        source_elem = self.get_element(element)
        to_elem = self.get_element(to_element)
        actions = ActionChains(self)
        actions.drag_and_drop(source_elem, to_elem)
        actions.perform()

    def submit(self, element):
        """
        Shortcut for submitting an element

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :return:
        """
        elem = self.get_element(element)
        elem.submit()

    def send_keys(self, keys):
        """
        Send arbitrary keys. Note: this is different than sending keys directly to an element.

        :param keys: keys to send
        :return:
        """
        actions = ActionChains(self)
        actions.send_keys(keys)
        actions.perform()

    def press_button(self, button):
        """
        Send a keystroke simulating the press of a given button. You can use keys as strings (e.g. 'a', 'z') or any
        key names (e.g. the 'escape' key). When the length of the button argument is greater than one character,
        names are checked against selenium.webdriver.common.keys.Keys first.

        :param button: A single character or key name
        :type button: str
        :return:
        """
        if len(button) > 1:
            button = getattr(Keys, button.upper(), button)
        self.send_keys(button)

    def scroll_to_bottom(self):
        """
        Scrolls the current window to the bottom of the window (0, document.body.scrollHeight).
        """
        self.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    def scroll_to_element(self, element):
        """
        Scroll to the location of an element.

        :param element: CSS Selector or XPATH used to locate the element
        :return:
        """
        location = self.get_element_location(element)
        x = location['x']
        y = location['y']
        self.scroll_to(x, y)

    def scroll_to(self, x, y):
        """
        Scroll to a particular (x, y) coordinate.

        :param x: the x coordinate to scroll to.
        :type x: int
        :param y: the y coordinate to scroll to.
        :type y: int
        :return:
        """
        # prevent script injection
        x = int(x)
        y = int(y)
        self.execute_script('window.scrollTo({}, {});'.format(x, y))

    def move_to_element(self, element, offset=None):
        """
        Moves the mouse to the middle of an element

        :param element: CSS Selector or XPATH used to locate the element
        :type element: str
        :param offset: optional tuple of x/y offsets to offset mouse from center
        :type offset: tuple
        :return:
        """
        elem = self.get_element(element)
        actions = ActionChains(self)
        if offset:
            actions.move_to_element_with_offset(elem, *offset)
        else:
            actions.move_to_element(elem)
        actions.perform()

    def pause(self, milliseconds):
        """
        Pause for a number of miliseconds.
        ``time.sleep`` is used here due to issues with w3c browsers and ActionChain pause feature.

        :param milliseconds: number of miliseconds to wait
        :type milliseconds: int
        :return:
        """
        seconds = round(milliseconds / 1000, 3)
        time.sleep(seconds)

    def wait_for_element_condition(self, element, ms, negative, condition):
        """
        Wait on an element until a certain condition is met, up to a maximum amount of time to wait.

        :param element: CSS Selector or XPATH used to locate the element
        :param ms: maximum time (in milliseconds) to wait for the condition to be true
        :param negative: whether or not the check for negation of condition. Will coarse boolean from value
        :param condition: the condition to check for. Defaults to checking for presence of element
        :return: element
        """
        if not ms:
            seconds = self.default_wait
        else:
            seconds = round(ms / 1000, 3)

        condition_text_map = {
            'be checked': element_is_selected,
            'be enabled': element_is_enabled,
            'be selected': element_is_selected,
            'be visible': element_is_visible,
            'contain a text': element_contains_text,
            'contain a value': element_contains_value,
            'exist': element_is_present,
        }

        if condition:
            expected = condition_text_map[condition]
        else:
            expected = element_is_present

        # if element.startswith('/'):
        #     locator = (By.XPATH, element)
        # else:
        #     locator = (By.CSS_SELECTOR, element)
        
        #上面注释部分重构为以下内容:
        if "=>" not in element:
            by = "css"
            value = element
            # wait element.
            self.element_wait(by, element)
        else:
            by = element.split("=>")[0]
            value = element.split("=>")[1]
            if by == "" or value == "":
                raise NameError("Grammatical errors,reference: 'id=>useranme'.")
            self.element_wait(by, value)
        if by == "id":
            locator = (By.ID, value)
        elif by == "name":
            locator = (By.NAME, value)
        elif by == "class":
            locator = (By.CLASS_NAME, value)
        elif by == "link_text":
            locator = (By.LINK_TEXT, value)
        elif by == "xpath":
            locator = (By.XPATH, value)
        elif by == "css":
            locator = (By.CSS_SELECTOR, value)
        else:
            raise NameError(
                "Please enter the correct targeting elements,'id','name','class','link_text','xpath','css'.")
        
        #以上为重构内容
        
        wait = WebDriverWait(self, seconds)

        try:
            result = wait.until(expected(locator, negative=bool(negative)))
        except TimeoutException:
            result = None

        return result

    def select_option(self, select_element, by, by_arg):
        """
        Implements features for selecting options in Select elements. Uses selenium's ``Select`` support class.

        :param select_element: CSS Selector or XPATH used to locate the select element containing options
        :param by: the method for selecting the option, valid options include any select_by_X supported by ``Select``.
        :type by: str
        :return:
        """

        select_elem = self.get_element(select_element)
        select = Select(select_elem)
        select_method = getattr(select, 'select_by_'+by, partial(select.select_by_attr, by))
        select_method(by_arg)

    @staticmethod
    def is_color(str_):
        """
        Whether or not the string represents a color.

        :param str_:
        :return:
        """
        try:
            Color.from_string(str_)
            return True
        except ValueError:
            return False
#以下为自己封装的
    def element_wait(self, by, value, secs=5):
        """
        显示等待 判断元素是否可见
        """
        if by == "id":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.ID, value)))
        elif by == "name":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.NAME, value)))
        elif by == "class":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.CLASS_NAME, value)))
        elif by == "link_text":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.LINK_TEXT, value)))
        elif by == "xpath":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.XPATH, value)))
        elif by == "css":
            WebDriverWait(self, secs, 0.5).until(EC.presence_of_element_located((By.CSS_SELECTOR, value)))
        else:
            raise NoSuchElementException("Not find element, Please check the syntax error.")

#重構了get_element方法，之前的注釋了
    def get_element(self, css):
        """css:元素定位方式 都加上了显示等待  返回一个元素对象
        例如:  "name=>email"
        """
        if "=>" not in css:
            by = "css"
            value = css
            # wait element.
            self.element_wait(by, css)
        else:
            by = css.split("=>")[0]
            value = css.split("=>")[1]
            if by == "" or value == "":
                raise NameError("Grammatical errors,reference: 'id=>useranme'.")
            self.element_wait(by, value)
        if by == "id":
            element = self.find_element_by_id(value)
        elif by == "name":
            element = self.find_element_by_name(value)
        elif by == "class":
            element = self.find_element_by_class_name(value)
        elif by == "link_text":
            element = self.find_element_by_link_text(value)
        elif by == "xpath":
            element = self.find_element_by_xpath(value)
        elif by == "css":
            element = self.find_element_by_css_selector(value)
        else:
            raise NameError(
                "Please enter the correct targeting elements,'id','name','class','link_text','xpath','css'.")
        return element
    
#增加了get_elements方法
    def get_elements(self, css):
        by = css.split("=>")[0]
        value = css.split("=>")[1]

        if by == "ids":
            element = self.find_elements_by_id(value)
        elif by == "names":
            element = self.find_elements_by_name(value)
        elif by == "classes":
            element = self.find_elements_by_class_name(value)
        elif by == "link_texts":
            element = self.ind_elements_link_text(value)
        elif by == "xpaths":
            element = self.find_elements_by_xpath(value)
        elif by == "csses":
            element = self.find_elements_by_css_selector(value)
        else:
            raise NameError(
                "Please enter the correct targeting elements,'ids','names','classes','link_texts','xpaths','csses'.")
        return element

    def WebDriverWait(self, secs=5):
        return WebDriverWait(self, secs, 0.5)

    def alert_is_pressent(self):
        """判断是否有弹出框"""
        ele = self.WebDriverWait().until(EC.alert_is_present())
        return ele

    def element_frame(self, css):
        """判断元素是否是frame 如果是 则切进去
        css: 定位方式 "id=>kw"
        """
        ele = self.get_element(css)
        try:
            self.WebDriverWait().until(EC.frame_to_be_available_and_switch_to_it(ele))
        except:
            raise ("switch to frame error  check" + css + "")

    def element_clickable(self, css):
        """判断元素是否可见可点击"""
        by = css.split("=>")[0]
        value = css.split("=>")[1]
        flag = None
        if by == "id":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.ID, value)))
        elif by == "name":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.NAME, value)))
        elif by == "class":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.CLASS_NAME, value)))
        elif by == "link_text":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.LINK_TEXT, value)))
        elif by == "xpath":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.XPATH, value)))
        elif by == "css":
            flag = self.WebDriverWait().until(EC.element_to_be_clickable((By.CSS_SELECTOR, value)))
        if flag:
            return flag
        else:
            raise ("元素不可点击")

        # 基本操作

    def open(self, url):
        """打开 url
        例如: driver.open("https://www.baidu.com")
        """
        self.get(url)

    def url(self):
        """
        获取当前界面的url地址
        例如:driver.get_url()
        """
        return self.current_url

    def title(self):
        """
        获取窗口的title
        例如:
        driver.get_title()
        """
        return self.title

    def window_source(self):
        return self.page_source

    def window_forward_back(self, str):
        """
        页面前进或者后退
        """
        if str == "forward":
            self.forward()
        elif str == "back":
            self.back()

    def F5(self):
        """刷新 例如:driver.F5()"""
        self.refresh()

    def max_window(self):
        """
        窗口最大化
        例如:driver.max_window()
        """
        self.maximize_window()

    def window_size(self):
        """获取窗口长宽"""
        self.get_window_size()

    def window_position(self):
        """窗口坐标"""
        return self.get_window_position()

    def window_rect(self):
        """获取窗口坐标以及长宽"""
        self.get_window_rect()

    def set_window(self, wide, high):
        """
        设置窗口的大小
        wide:长
        high:高
        例如:driver.set_window(wide,high)
        """
        self.set_window_size(wide, high)

    def close(self):
        """
        关闭浏览器
        例如:driver.close()
        """
        self.close()

    def quit(self):
        """
        关闭浏览器进程
        例如:driver.quit()
        """
        self.quit()

    def click_text(self, text):
        """
        根据link_text定位 并做点击操作
        例如:driver.click_text("新闻")
        """
        self.find_element_by_partial_link_text(text).click()

    def wait(self, secs):
        """
        隐式等待
        例如:driver.wait(10)
        """
        self.implicitly_wait(secs)

    def current_windows_screenshot(self, file_path):
        """
        当前窗口截图
        例如:driver.current_windows_screenshot()
        """
        return self.get_screenshot_as_file(file_path)

    def get_screenshot_as_base64(self):
        return self.get_screenshot_as_base64()

        # 窗口句柄的操作

    def current_window_handle(self):
        """获取当前窗口句柄"""
        return self.current_window_handle

    def open_new_window(self, css):
        """
        如果做点击操作会打开新的界面 则切换过去
        例如:driver.open_new_window("link_text=>注册")
        """
        original_window = self.current_window_handle
        el = self.get_element(css)
        el.click()
        all_handles = self.window_handles
        for handle in all_handles:
            if handle != original_window:
                self.switch_to.window(handle)

    def windows_handle_cut(self, index):
        """窗口的句柄的切换,只要需要切换到第几个窗口即可
        例如:driver.window_han(0)"""

        all_handle = self.window_handles
        self.switch_to.window(all_handle[index])

        # 弹出框操作

    def alert_text(self):
        """获取一个弹出框的文本值 这个地方加了一个窗口的切换  防止windows弹窗"""
        flag = None
        try:
            ele = self.alert_is_pressent()
            flag = ele.text
        except:
            try:
                alert = Alert(self)
                flag = alert.text
            except:
                try:
                    self.windows_handle_cut(index=1)
                    self.alert_text()
                except:
                    raise ("not find alert")
        return flag

    def alert_accept(self):
        """弹出框的确定"""
        try:
            ele = self.alert_is_pressent()
            ele.accept()
        except:
            try:
                alert = Alert(self)
                alert.accept()
            except:
                raise ("not find alert")

    def alert_dismiss(self):
        """弹出框的取消"""
        try:
            ele = self.alert_is_pressent()
            ele.dismiss()
        except:
            try:
                alert = self.switch_to_alert()
                alert.dismiss()
            except:
                try:
                    alert = Alert(self)
                    alert.dismiss()
                except:
                    raise ("not find alert")

    def alert_sendkeys(self, string):
        """在弹出框中输入内容"""
        try:
            ele = self.alert_is_pressent()
            ele.send_keys(string)
        except:
            try:
                alert = self.switch_to_alert()
                alert.send_keys(string)
            except:
                try:
                    alert = Alert(self)
                    alert.send_keys(string)
                except:
                    raise ("not find alert")

        # 元素的click send submit clear doub

    def element_click(self, css):
        """
        元素定位并且做点击操作
        例如:driver.click("id=>kw")
        """
        ele = self.get_element(css)
        ele.click()

    def element_send(self, css, text):
        """
        元素定位并且输入
        例如:driver.type("id=>kw","ui自动化")
        """
        ele = self.get_element(css)
        ele.send_keys(text)

    def element_send_submit(self, css, value):
        """输入并提交"""
        self.element_send(css, value)
        self.element_submit(css)

    def element_submit(self, css):
        """
        定位元素并且提交
        例如:driver.submit("id=>su")
        """
        ele = self.get_element(css)
        ele.submit()

    def element_clear(self, css):
        """
        元素定位且清空输入
        例如:driver.clear("id=>kw")
        """
        ele = self.get_element(css)
        ele.clear()

        # 奇奇怪怪的鼠标事件 左键双击 单击右键  拖拽

    def element_right_click(self, css):
        """
        在某个元素上进行鼠标右击
        例如:driver.right_click("id=>kw")
        """
        ele = self.get_element(css)
        ActionChains(self).context_click(ele).perform()

    def element_left_click(self, ele):
        """
        在某个元素上进行鼠标z左击
        例如:driver.click("id=>kw")
        """
        # ele = self.get_element(css)
        ActionChains(self).click(ele).perform()

    def move_to_element(self, css):
        """
        鼠标悬停
        例如:driver.move_to_element("css=>#el")
        """
        ele = self.get_element(css)
        ActionChains(self).move_to_element(ele).perform()

    def element_double_click(self, css):
        """
        元素双击操作
        例如:driver.double_click("css=>#el")
        """
        ele = self.get_element(css)
        ActionChains(self).double_click(ele).perform()

    def drag_and_drop(self, el_css, ta_css):
        """
        元素拖动
        el_css:起始元素
        ta_css:目标位置
        例如:driver.drag_and_drop("css=>#el","css=>#ta")
        """
        element = self.get_element(el_css)
        target = self.get_element(ta_css)
        ActionChains(self).drag_and_drop(element, target).perform()

        #  键盘事件 摒弃 key_down key_up 这套

    def key(self, css, value):
        """键盘的删除 空格 tab esc"""
        if value == "back":
            self.get_element(css).send_keys(Keys.BACK_SPACE)
        elif value == "space":
            self.get_element(css).send_keys(Keys.SPACE)
        elif value == "tab":
            self.get_element(css).send_keys(Keys.TAB)
        elif value == "esc":
            self.get_element(css).send_keys(Keys.ESCAPE)

    def keys(self, css, value):
        """control+value  比如 a c v x"""
        self.get_element(css).send_keys(Keys.CONTROL, value)

        # 疑难问题上js

    def js(self, script):
        """
        执行js
        例如:driver.js("window.scrollTo(200,1000);")
        """
        self.execute_script(script)

    def scrollbar(self, left, top):
        """滚动条的操作
        left:距离最左边距离
        top:距离最上边距离"""
        js = "window.scrollTo(" + str(left) + "," + str(top) + ");"
        self.js(js)

    def remove_readonly(self, id):
        """
        当元素有唯一的id属性 并且需要移除readonly时候 可以用这个函数
        一般用在日期控件上,但是需要注意的是  必须要先clear 再send
        移除readonly属性
        或者用.readonly=false
        肯定是先要定位到具体的
        """
        js2 = "document.getElementById('" + id + "').removeAttribute('readonly')"
        self.js(js2)

    def get_attribute_inner(self, css):
        """获取某个元素的innerHtml属性"""
        ele = self.get_element(css)
        return ele.get_attribute("innerHTML")

        # frame的操作

    def switch_to_frame(self, css):
        """
        切入frame
        例如:driver.switch_to_frame("id=>kw")
        需要注意的是 frame结构 需要层层切入  例如
        一个frame嵌套一个frame  则去要层层切入
        """
        try:
            self.element_frame(css)
        except:
            try:
                iframe_ele = self.get_element(css)
                self.switch_to.frame(iframe_ele)
            except:
                raise ("switch to frame error  check" + css + "")

    def switch_to_frame_up(self):
        """切换到上一层frame"""
        self.switch_to.parent_frame()

    def switch_to_frame_out(self):
        """
        退出frame 结束表单操作
        例如:driver.switch_to_frame_out()
        """
        self.switch_to.default_content()

    def element_display(self, css):
        """
        判断元素是否可见
        例如:driver.get_display("id=>kw")
        """
        ele = self.get_element(css)
        return ele.is_displayed()

    def element_enabled(self, css):
        """判断元素是否可操作
        例如:driver.get_enabled("id=>kw")
        """
        ele = self.get_element(css)
        return ele.is_enabled()

        # # 表格的验证 共多少行  多少列  每行每列数据
        # def table_count_col(self,css):
        #     """表格多少列"""
        #     ele=self.get_elements(""+css+"/tr[1]/td")
        #     return len(ele)
        #
        # def table_count_row(self,css):
        #     """表格多少行"""
        #     ele=self.get_elements(""+css+"/tr")
        #     return len(ele)
        #
        # def table_cell_value(self,css,row,col):
        #     """
        #     获取指定单元格数据
        #     row:行
        #     col:列
        #     定位到table即可"""
        #     return self.get_element(""+css+"/tr["+str(row)+"]/td["+str(col)+"]").text
        #
        # def table_row_values(self,css,row):
        #     """获取table一行数据"""
        #     num=self.table_row(css)
        #     row_list=[]
        #     ele = self.get_elements("" + css + "/tr["+str(row)+"]")
        #     for i in ele:
        #         value=i.text
        #     a=value.split(" ")
        #     return a
        #
        # def table_col_values(self,css,col):
        #     """获取表格一列数据"""
        # #    先获取一行数据  再获取所有行数据  根据 每行的下标取值
        # #   num table的所有行
        #     num=self.table_row(css)
        #     all_col_values=[]
        #     # 下面需要注意实际行数是从1开始  而不是0  所以 所以用num+1 而不是num
        #     for i in range(1,num+1):
        #         all_row_values=self.table_row_values(css,i)
        #         # 下面这个是因为输入的列是从1开始  但是列表下标是从0开始
        #         num1=col-1
        #         all_col_values.append(all_row_values[num1])
        #     return all_col_values

        # 下拉框 单选 复选   单/多行 点击 取消 返回text

    def select_click(self, css, value):
        """
        下拉框的点击操作  value 为:行(0为起始行 注意了 ) text value值 都行
        """
        ele = self.get_element(css)
        if isinstance(value, str):
            try:
                Select(ele).select_by_value(value)
            except:
                Select(ele).select_by_visible_text(value)
        elif isinstance(value, int):
            Select(ele).select_by_index(value)

    def select_all_optinon(self, css):
        """获取所有select的option 方便下面做遍历"""
        return Select(self.get_element(css)).options

    def select_all_text(self, css):
        """下拉的所有text"""
        all_options = self.select_all_optinon(css)
        all_text = []
        for i in all_options:
            all_text.append(i.text)
        return all_text

    def select_circulation_click(self, css):
        """对下拉框挨个点击 并返回text值"""
        ele = self.select_all_optinon(css)
        select_all_value = []
        for select in ele:
            select.click()
            select_all_value.append(select.text)
        return select_all_value

    def select_uclick(self, css, value):
        """取消单行选中"""
        ele = self.get_element(css)
        if isinstance(value, str):
            try:
                Select(ele).deselect_by_value(value)
            except:
                Select(ele).deselect_by_visible_text(value)
        elif isinstance(value, int):
            Select(ele).deselect_by_index(value)

    def select_more_uclick(self, css, *value):
        """取消多行选中"""
        ele = self.get_element(css)
        for i in range(len(value)):
            Select(ele).deselect_by_index(value[i])

    def select_more_click(self, css, *value):
        """选中多行 并返回text"""
        ele = self.get_element(css)
        # 先去的所有value值  然后 通过传进来的参数 取相应的数据
        all_value = self.select_all_text(css)
        more_value = []
        for i in range(len(value)):
            Select(ele).select_by_index(value[i])
            print(value[i])
            more_value.append(all_value[value[i]])
        return more_value

    def select_all_uclick(self, css):
        """取消所有行选中"""
        ele = self.get_element(css)
        Select(ele).deselect_all()

        # 上传/下载基于坐标 下载修改了webdriver的配置
        # def send_file(self,x,y,x1,y1):
        #     """上传 基于坐标 拿尺子量坐标吧 .."""
        #     m = PyMouse()
        #     m.click(x,y)
        #     m.click(x1,y1)

        # cookies相关

    def get_cookies(self):
        """获取所有cookie"""
        self.get_cookies()

    def get_cookie_name(self, name):
        """获取指定name的cookie"""
        self.get_cookie(name)

    def add_cookie(self, **cookies):
        """添加cookie
        例如:driver.add_cookie(a=b,c=d)"""

        self.add_cookie(**cookies)

    def del_cookie(self, name):
        """删除指定cookie"""
        self.delete_cookie(name)

    def del_all_cookie(self):
        """删除所有cookies"""
        self.delete_all_cookies()

        # 元素的一些判断

    def element_is_seen(self, css, secs=5):
        """判断元素是否可见"""
        by = css.split("=>")[0]
        value = css.split("=>")[1]
        if by == "id":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.ID, value)))
        elif by == "name":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.NAME, value)))
        elif by == "class":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.CLASS_NAME, value)))
        elif by == "link_text":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.LINK_TEXT, value)))
        elif by == "xpath":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.XPATH, value)))
        elif by == "css":
            WebDriverWait(self, secs, 0.5).until(EC.element_to_be_clickable((By.CSS_SELECTOR, value)))
        else:
            raise NoSuchElementException(
                "Not find element, Please check the syntax error.")

    def element_is_selectd(self, css):
        """查看元素是否被选中"""
        return self.get_element(css).is_selected()

    def element_is_displayed(self, css):
        """查看元素是否隐藏"""
        return self.get_element(css).is_displayed()

    def element_is_enabled(self, css):
        """判断元素是否可以操作"""
        return self.get_element(css).is_enabled()

    def element_html(self, css, str):
        """获取元素的基本信息如text tagname size"""
        flag = None
        if str == "text":
            flag = self.get_element(css).text
        elif str == "tag":
            flag = self.get_element(css).tag_name
        elif str == "size":
            flag = self.get_element(css).size
        if flag:
            return flag
        else:
            raise ("str must be text,tag,size")

    def element_attribute(self, css, str):
        """获取元素属性值 比如 id name  value"""
        flag = self.get_element(css).get_attribute(str)
        if flag:
            return flag
        else:
            raise ("str must be id,name,value... ")

    def element_css(self, css, value):
        """获取元素样式 例如font  height width  这个地方底层没有错误返回"""
        return self.get_element(css).value_of_css_property(value)

    def element_message(self, css, str):
        """获取元素内所有信息 只要给个关键词 无论标签还是属性或者是css样式 """
        flag = None
        try:
            flag = self.element_message(css, str)
        except:
            try:
                flag = self.element_attribute(css, str)
            except:
                flag = self.element_css(css, str)
        return flag
#以上为自己封装的

class Chrome(BehaveDriverMixin, webdriver.Chrome):
    """
    Chrome driver class. Alternate constructors and browser-specific logic is implemented here.
    """
    _driver_name = 'chromedriver'
    @classmethod
    def headless(cls, *args, **kwargs):
        chrome_options = kwargs.pop('chrome_options', None)
        if chrome_options is None:
            chrome_options = ChromeOptions()
        chrome_options.add_argument('--headless')
        chrome_options.add_argument('--disable-gpu')
        kwargs['chrome_options'] = chrome_options
        return cls(*args, **kwargs)


class PhantomJS(BehaveDriverMixin, webdriver.PhantomJS):
    """
    PhantomJS driver class. Alternate constructors and browser-specific logic is implemented here.
    """
    pass


class Firefox(BehaveDriverMixin, webdriver.Firefox):
    """
    Firefox driver class. Alternate constructors and browser-specific logic is implemented here.
    """
    _driver_name = 'geckodriver'
    @classmethod
    def headless(cls, *args, **kwargs):
        firefox_options = kwargs.pop('firefox_options', None)
        if firefox_options is None:
            firefox_options = FirefoxOptions()
        firefox_options.add_argument('--headless')
        kwargs['firefox_options'] = firefox_options
        return cls(*args, **kwargs)

    @property
    def secondary_handles(self):
        self.switch_to.window(self.current_window_handle)
        try:
            # FIXME: there must be a better way
            self.wait(1).until(EC.new_window_is_opened(self.window_handles))
            self.switch_to.window(self.current_window_handle)
        except TimeoutException:
            pass
        return super(Firefox, self).secondary_handles

    @property
    def last_opened_handle(self):
        self.switch_to.window(self.current_window_handle)
        return super(Firefox, self).last_opened_handle

    def click_element(self, element):
        self.scroll_to_element(element)
        super(Firefox, self).click_element(element)

    def doubleclick_element(self, element):
        """
        Overrides the doubleclick method to first scroll to element, and adds JS shim for doubleclick
        """
        self.scroll_to_element(element)
        elem = self.get_element(element)
        script = ("var evObj = new MouseEvent('dblclick', {bubbles: true, cancelable: true, view: window}); "
                  " arguments[0].dispatchEvent(evObj);")
        self.execute_script(script, elem)

    def move_to_element(self, element, offset=None):
        self.scroll_to_bottom()
        self.scroll_to_element(element)
        super(Firefox, self).move_to_element(element, offset=offset)


class Ie(BehaveDriverMixin, webdriver.Ie):
    """
    Ie driver class. Alternate constructors and browser-specific logic is implemented here.
    """
    _driver_name = 'IEDriverServer'


class Edge(BehaveDriverMixin, webdriver.Edge):
    """
    Edge driver class. Alternate constructors and browser-specific logic is implemented here.
    """


class Opera(BehaveDriverMixin, webdriver.Opera):
    """
    Opera driver class. Alternate constructors and browser-specific logic is implemented here.
    """


class Safari(BehaveDriverMixin, webdriver.Safari):
    """
    Safari driver class. Alternate constructors and browser-specific logic is implemented here.
    """
    _driver_name = 'safaridriver'


class BlackBerry(BehaveDriverMixin, webdriver.BlackBerry):
    """
    BlackBerry driver class. Alternate constructors and browser-specific logic is implemented here.
    """


class Android(BehaveDriverMixin, webdriver.Android):
    """
    Android driver class. Alternate constructors and browser-specific logic is implemented here.
    """


class Remote(BehaveDriverMixin, webdriver.Remote):
    """
    Remote driver class. Alternate constructors and browser-specific logic is implemented here.
    """

